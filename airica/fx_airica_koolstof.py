"""Import and parse the data files produced by the Marianda AIRICA."""

import pandas as pd
import numpy as np
from matplotlib import dates as mdates
from scipy import stats
import seaborn as sns
from calkulate.density import seawater_1atm_MP81
import matplotlib.pyplot as plt
import itertools


# Extract data from dbs
mapper_dbs = {
    "run type": "run_type",
    "i.s. temp.": "temperature_insitu",
    "sample mass": "mass_sample",
    "rep#": "rep",
    "CT": "dic",
    "factor CT": "dic_factor",
    "CV (Âµmol)": "cv_micromol",
    "CV (%)": "cv_percent",
    "last CRM CT": "lastcrm_dic_measured",
    "cert. CRM CT": "lastcrm_dic_certified",
    "CRM batch": "lastcrm_batch",
    "calc. mode": "mode_calculation",
    "integ. mode": "mode_integration",
    "Lat.": "latitude",
    "Long.": "longitude",
    "area#1": "area_1",
    "area#2": "area_2",
    "area#3": "area_3",
    "area#4": "area_4",
}


def read_dbs(filepath_or_buffer, encoding="unicode_escape", na_values="none", **kwargs):
    """Import the dbs file generated by a Marianda AIRICA as a pandas DataFrame.
    All kwargs are passed to pandas.read_table.
    """
    dbs = pd.read_table(
        filepath_or_buffer, encoding=encoding, na_values=na_values, **kwargs
    )
    dbs.rename(mapper=mapper_dbs, axis=1, inplace=True)
    if "Unnamed: 32" in dbs:
        dbs.drop(columns="Unnamed: 32", inplace=True)
    dbs["datetime"] = pd.to_datetime(
        dbs.apply(lambda x: " ".join((x.date, x.time)), axis=1)
    )
    dbs["datenum"] = mdates.date2num(dbs.datetime)
    dbs["volume_sample"] = (dbs.mass_sample / dbs.density).round()  # microlitres
    return dbs


def process_airica(
    # crms_val,
    db,
    dbs_filepath,
    results_file_path_and_name=None,
    draw_figure=True,
):
    """Process AIRICA raw data by extracting data from .dbs file and
    adding it to .xlsx file, calculating conversion factor from CRMs for
    each analysis batch and computing TCO2 values.
    """

    # Import ".dbs" file
    dbs = read_dbs(dbs_filepath)

    # Add ".dbs" data to ".xlsx"
    db = pd.merge(left=db, right=dbs, how="left", left_on="name", right_on="bottle")

    # Drop useless columns
    db = db.loc[:, ~db.columns.str.endswith("_y")]
    db.columns = db.columns.str.replace("_x", "")

    # Recalculate density
    db["density_analysis"] = np.nan
    db["density_analysis"] = seawater_1atm_MP81(
        temperature=db.temperature, salinity=db.salinity
    )

    # Average areas with only last 3 areas
    db["area_av_3"] = (db.area_2 + db.area_3 + db.area_4) / 3

    # Calculate DIC * density * sample_v
    L = db["name"].str.startswith("CRM-189-")
    db.loc[L, "CT_d_sample_v"] = 2009.48 * db.density_analysis * db.sample_v
    L = db["name"].str.startswith("CRM-195-")
    db.loc[L, "CT_d_sample_v"] = 2024.96 * db.density_analysis * db.sample_v

    # Calculate CRM coeff factor
    def get_CF(db):
        """Calculate conversion factor CF for each analysis batch."""
        b, a = stats.linregress(db.area_av_3, db.CT_d_sample_v)[:2]
        return pd.Series({"a": a, "b": b})

    L = db["reference_good"] == True
    db_cf = db[L]
    db_cf = db_cf.groupby(by=["analysis_batch"]).apply(get_CF).reset_index()

    print(db_cf)

    # Assign CRM a and b to samples based on analysis batch
    db = pd.merge(left=db, right=db_cf, how="left", on="analysis_batch")

    # Calculate TCO2 values
    db["TCO2"] = ((db.b * db.area_av_3) + db.a) / (db.density_analysis * db.sample_v)

    if draw_figure:
        # Prepare colours and markers
        markers = itertools.cycle(("o", "^", "s", "v", "D", "<", ">"))
        colors = itertools.cycle(
            (
                "xkcd:purple",
                "xkcd:green",
                "xkcd:blue",
                "xkcd:pink",
                "xkcd:deep blue",
                "xkcd:red",
                "xkcd:teal",
                "xkcd:orange",
                "xkcd:fuchsia",
            )
        )
        # Plot linear regresion of CRM calibration
        batches = db["analysis_batch"].unique().tolist()

        # Create figure
        f, ax = plt.subplots(dpi=300)

        # Linear regression through CRMs used for calibration
        # L = db.location == "CRM"
        sns.regplot(
            x=db.area_av_3[L],
            y=db.CT_d_sample_v[L],
            scatter=False,
            color="xkcd:black",
            ci=False,
            ax=ax,
            line_kws={"zorder": 0, "linestyle": "--", "alpha": 0.7},
        )

        # Scatter CRM points
        for batch in batches:
            L = db["analysis_batch"] == batch
            data = db[L]
            m = next(markers)
            c = next(colors)

            L = db.location == "CRM"

            sns.scatterplot(
                x=data.area_av_3[L],
                y=data.CT_d_sample_v[L],
                ci=False,
                color=c,
                marker=m,
                label=data["analysis_date"].unique(),
                ax=ax,
            )

        # Improve figure
        xmin = round(db[L]["area_av_3"].min() - 500)
        xmax = round(db[L]["area_av_3"].max() + 500)
        plt.xlim([xmin, xmax])

        ax.set_xlabel("$AREA_{average}$")
        ax.set_ylabel("$TCO_{2}$ x density x volume")

        ax.grid(alpha=0.3)
        ax.legend(title="Analysis date", fontsize="small", fancybox=True)

        # Add R2^2 to graph
        r = stats.linregress(db.area_av_3[L], db.CT_d_sample_v[L])[2]
        r2 = r ** 2
        r2s = str(round(r2, 2))
        text = "$R^2$ = " + r2s
        plt.annotate(text, xy=(0.3, 0.925), xycoords="axes fraction")

    # Save results as text file
    if results_file_path_and_name is not None:
        db.to_csv(results_file_path_and_name, index=None)

    return db
