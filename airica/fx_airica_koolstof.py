"""Import and parse the data files produced by the Marianda AIRICA."""

import pandas as pd
import numpy as np
from matplotlib import dates as mdates
from scipy import stats
import seaborn as sns
from calkulate.density import seawater_1atm_MP81
import matplotlib.pyplot as plt


# Extract data from dbs
mapper_dbs = {
    "run type": "run_type",
    "i.s. temp.": "temperature_insitu",
    "sample mass": "mass_sample",
    "rep#": "rep",
    "CT": "dic",
    "factor CT": "dic_factor",
    "CV (Âµmol)": "cv_micromol",
    "CV (%)": "cv_percent",
    "last CRM CT": "lastcrm_dic_measured",
    "cert. CRM CT": "lastcrm_dic_certified",
    "CRM batch": "lastcrm_batch",
    "calc. mode": "mode_calculation",
    "integ. mode": "mode_integration",
    "Lat.": "latitude",
    "Long.": "longitude",
    "area#1": "area_1",
    "area#2": "area_2",
    "area#3": "area_3",
    "area#4": "area_4",
}


def read_dbs(filepath_or_buffer, encoding="unicode_escape", na_values="none", **kwargs):
    """Import the dbs file generated by a Marianda AIRICA as a pandas DataFrame.
    All kwargs are passed to pandas.read_table.
    """
    dbs = pd.read_table(
        filepath_or_buffer, encoding=encoding, na_values=na_values, **kwargs
    )
    dbs.rename(mapper=mapper_dbs, axis=1, inplace=True)
    if "Unnamed: 32" in dbs:
        dbs.drop(columns="Unnamed: 32", inplace=True)
    dbs["datetime"] = pd.to_datetime(
        dbs.apply(lambda x: " ".join((x.date, x.time)), axis=1)
    )
    dbs["datenum"] = mdates.date2num(dbs.datetime)
    dbs["volume_sample"] = (dbs.mass_sample / dbs.density).round()  # microlitres
    return dbs


def process_airica(
    # crms_val,
    db,
    dbs_filepath,
    results_file_path_and_name=None,
    draw_figure=True,
):
    """Process AIRICA raw data by extracting data from .dbs file and
    adding it to .xlsx file, calculating conversion factor from CRMs and
    computing TCO2 values.
    """

    # Import ".dbs" file
    dbs = read_dbs(dbs_filepath)

    # Add ".dbs" data to ".xlsx"
    db = pd.merge(left=db, right=dbs, how="left", left_on="name", right_on="bottle")
    
    # Drop useless columns
    db = db.loc[:, ~db.columns.str.endswith('_y')]
    db.columns = db.columns.str.replace('_x', '')

    # Check that ".dbs" bottle = ".xlsx" name and drop "bottle" column
    if db["name"].equals(db["bottle"]):
        print("SUCCESSFUL DBS IMPORT")
        db = db.drop(columns=["bottle"])
    else:
        KeyError
        print("ERROR: mismatch between dbs and xlsx files. Please \
              check pandas Series. ")
        
        mismatch = pd.DataFrame()
        mismatch['dbs_name'] = dbs['bottle']
        mismatch['db_name'] = db['name']
        return mismatch
    
    # Recalculate density
    db["density_analysis"] = np.nan
    db["density_analysis"] = seawater_1atm_MP81(
        temperature=db.temperature, salinity=db.salinity
    )

    # Average areas with all areas and only last 3 areas
    db["area_av_4"] = (db.area_1 + db.area_2 + db.area_3 + db.area_4) / 4
    db["area_av_3"] = (db.area_2 + db.area_3 + db.area_4) / 3
   

    # Calculate DIC * density * sample_v
    L = db["name"].str.startswith("CRM-189-")
    db.loc[L, "CT_d_sample_v"] = 2009.48 * db.density_analysis * db.sample_v
    L = db["name"].str.startswith("CRM-195-")
    db.loc[L, "CT_d_sample_v"] = 2024.96 * db.density_analysis * db.sample_v

    # Create columns to hold conversion factor (CF) values
    # db["a_3"] = np.nan
    # db["a_4"] = np.nan
    # db["b_3"] = np.nan
    # db["b_4"] = np.nan

    # Calculate CRM coeff factor
    def get_CF(db):
        """Calculate conversion factor CF for each analysis batch."""
        b_3, a_3 = stats.linregress(db.area_av_3, db.CT_d_sample_v)[:2]
        b_4, a_4 = stats.linregress(db.area_av_3, db.CT_d_sample_v)[:2]
        return pd.Series({"a_3": a_3, "a_4": a_4, "b_3": b_3, "b_4": b_4})

    L = db.location == "CRM"
    db_cf = db[L]
    db_cf = db_cf.groupby(by=["analysis_batch"]).apply(get_CF).reset_index()

    # Assign CRM a and b to samples based on analysis batch
    db = pd.merge(left=db, right=db_cf, how="left", on="analysis_batch")        
        
    # db["a_3"] = db_cf.loc[db.analysis_batch.values, "a_3"].values
    # db["a_4"] = db_cf.loc[db.analysis_batch.values, "a_4"].values
    # db["b_3"] = db_cf.loc[db.analysis_batch.values, "b_3"].values
    # db["b_4"] = db_cf.loc[db.analysis_batch.values, "b_4"].values

    # Calculate TCO2 values
    db["TCO2_3"] = np.nan
    db["TCO2_4"] = np.nan
    db["TCO2_3"] = ((db.b_3 * db.area_av_3) + db.a_3) / (
        db.density_analysis * db.sample_v
    )
    db["TCO2_4"] = ((db.b_4 * db.area_av_4) + db.a_4) / (
        db.density_analysis * db.sample_v
    )

    if draw_figure:
        # Plot linear regresion of CRM calibration
        # Create figure
        f, ax = plt.subplots(dpi=300)

        # Scatter plot CRM data
        L = db.location == "CRM"
        sns.regplot(
            x=db.area_av_3[L],
            y=db.CT_d_sample_v[L],
            ci=False,
            color="xkcd:primary blue",
        )

        xmin = 15000 #db['area_av_3'].min()
        xmax = 30000 #db['area_av_3'].max()
        plt.xlim([xmin, xmax])

        # Add R2^2 to graph
        r2 = stats.linregress(db.area_av_3[L], db.CT_d_sample_v[L])[2]
        r2s = str(round(r2, 2))
        text = "$R^2$ = " + r2s
        text_x = db.area_av_3.max()*0.75
        text_y = db.CT_d_sample_v.max()*0.9
        ax.text(text_x, text_y, text, horizontalalignment='left',
            verticalalignment='center', fontsize=15)

        # Improve figure
        ax.grid(alpha=0.3)
        plt.tight_layout()

    # Save results as text file
    if results_file_path_and_name is not None:
        db.to_csv(results_file_path_and_name, index=None)

    return db